/**
 * Generate Powerset Index Script
 *
 * Scans all modular powerset directories and generates the index.ts file.
 * Usage: node scripts/generate-powerset-index.cjs
 */

const fs = require('fs');
const path = require('path');

const POWERSETS_PATH = './src/data/powersets';
const OUTPUT_FILE = './src/data/powersets/index.ts';

// Convert kebab-case to camelCase
function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
}

// Convert kebab-case to PascalCase
function toPascalCase(str) {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

// Get all powerset directories
function getPowersets() {
  const archetypes = fs.readdirSync(POWERSETS_PATH)
    .filter(item => {
      const itemPath = path.join(POWERSETS_PATH, item);
      return fs.statSync(itemPath).isDirectory();
    });

  const powersets = [];

  for (const archetype of archetypes) {
    for (const type of ['primary', 'secondary', 'epic']) {
      const typePath = path.join(POWERSETS_PATH, archetype, type);
      if (!fs.existsSync(typePath)) continue;

      const sets = fs.readdirSync(typePath)
        .filter(item => {
          const itemPath = path.join(typePath, item);
          return fs.statSync(itemPath).isDirectory() &&
                 fs.existsSync(path.join(itemPath, 'index.ts'));
        });

      for (const set of sets) {
        powersets.push({
          archetype,
          type,
          set,
          importPath: `./${archetype}/${type}/${set}`,
          varName: `${toCamelCase(archetype)}${toPascalCase(set)}`
        });
      }
    }
  }

  return powersets;
}

// Generate the index file content
function generateIndex(powersets) {
  // Group by archetype for organized imports
  const byArchetype = {};
  for (const ps of powersets) {
    if (!byArchetype[ps.archetype]) {
      byArchetype[ps.archetype] = [];
    }
    byArchetype[ps.archetype].push(ps);
  }

  let content = `/**
 * Modular Powerset Index (Auto-Generated)
 *
 * This file aggregates all converted modular powersets into a single registry.
 * Generated by: node scripts/generate-powerset-index.cjs
 *
 * Total powersets: ${powersets.length}
 */

import type { Powerset } from '@/types';

`;

  // Generate imports grouped by archetype
  for (const [archetype, sets] of Object.entries(byArchetype).sort()) {
    content += `// ============================================\n`;
    content += `// ${archetype.toUpperCase()} POWERSETS\n`;
    content += `// ============================================\n`;
    for (const ps of sets.sort((a, b) => a.set.localeCompare(b.set))) {
      content += `import { powerset as ${ps.varName} } from '${ps.importPath}';\n`;
    }
    content += '\n';
  }

  // Generate the array
  content += `// ============================================\n`;
  content += `// REGISTRY\n`;
  content += `// ============================================\n\n`;
  content += `const ALL_MODULAR_POWERSETS: Powerset[] = [\n`;

  for (const [archetype, sets] of Object.entries(byArchetype).sort()) {
    content += `  // ${archetype.charAt(0).toUpperCase() + archetype.slice(1)}\n`;
    for (const ps of sets.sort((a, b) => a.set.localeCompare(b.set))) {
      content += `  ${ps.varName},\n`;
    }
    content += '\n';
  }

  content += `];\n\n`;

  // Generate the registry builder and exports
  content += `/**
 * Build the registry from the array of powersets
 */
function buildRegistry(powersets: Powerset[]): Record<string, Powerset> {
  const registry: Record<string, Powerset> = {};
  for (const ps of powersets) {
    if (ps.id) {
      registry[ps.id] = ps;
    }
  }
  return registry;
}

/**
 * All modular powersets indexed by their ID.
 * These take precedence over powersets-raw.ts data when merged.
 */
export const MODULAR_POWERSETS: Record<string, Powerset> = buildRegistry(ALL_MODULAR_POWERSETS);

/**
 * Get the count of modular powersets
 */
export function getModularPowersetCount(): number {
  return Object.keys(MODULAR_POWERSETS).length;
}

/**
 * Check if a powerset has been converted to modular format
 */
export function isModularPowerset(id: string): boolean {
  return id in MODULAR_POWERSETS;
}
`;

  return content;
}

// Main
const powersets = getPowersets();
console.log(`Found ${powersets.length} powersets`);

const content = generateIndex(powersets);
fs.writeFileSync(OUTPUT_FILE, content);
console.log(`Generated ${OUTPUT_FILE}`);
